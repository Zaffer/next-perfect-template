/* tslint:disable */
/* eslint-disable */
/**
 * QuickDesk
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BodyCreateUserOpenApiV1UsersOpenPost
 */
export interface BodyCreateUserOpenApiV1UsersOpenPost {
    /**
     * 
     * @type {string}
     * @memberof BodyCreateUserOpenApiV1UsersOpenPost
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateUserOpenApiV1UsersOpenPost
     */
    email_address: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateUserOpenApiV1UsersOpenPost
     */
    full_name?: string;
}
/**
 * 
 * @export
 * @interface BodyResetPasswordApiV1ResetPasswordPost
 */
export interface BodyResetPasswordApiV1ResetPasswordPost {
    /**
     * 
     * @type {string}
     * @memberof BodyResetPasswordApiV1ResetPasswordPost
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof BodyResetPasswordApiV1ResetPasswordPost
     */
    new_password: string;
}
/**
 * 
 * @export
 * @interface BodyUpdateUserMeApiV1UsersMePut
 */
export interface BodyUpdateUserMeApiV1UsersMePut {
    /**
     * 
     * @type {string}
     * @memberof BodyUpdateUserMeApiV1UsersMePut
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyUpdateUserMeApiV1UsersMePut
     */
    full_name?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyUpdateUserMeApiV1UsersMePut
     */
    email_address?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyUpdateUserMeApiV1UsersMePut
     */
    whatsapp_number?: string;
}
/**
 * 
 * @export
 * @interface Building
 */
export interface Building {
    /**
     * 
     * @type {string}
     * @memberof Building
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Building
     */
    company_id: number;
    /**
     * 
     * @type {string}
     * @memberof Building
     */
    physical_address?: string;
    /**
     * 
     * @type {string}
     * @memberof Building
     */
    gps_co_ords?: string;
    /**
     * 
     * @type {string}
     * @memberof Building
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof Building
     */
    create_date?: string;
    /**
     * 
     * @type {Company}
     * @memberof Building
     */
    company: Company;
}
/**
 * 
 * @export
 * @interface BuildingCreate
 */
export interface BuildingCreate {
    /**
     * 
     * @type {string}
     * @memberof BuildingCreate
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof BuildingCreate
     */
    company_id: number;
    /**
     * 
     * @type {string}
     * @memberof BuildingCreate
     */
    physical_address?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildingCreate
     */
    gps_co_ords?: string;
}
/**
 * 
 * @export
 * @interface BuildingUpdate
 */
export interface BuildingUpdate {
    /**
     * 
     * @type {string}
     * @memberof BuildingUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildingUpdate
     */
    physical_address?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildingUpdate
     */
    gps_co_ords?: string;
    /**
     * 
     * @type {number}
     * @memberof BuildingUpdate
     */
    company_id?: number;
}
/**
 * 
 * @export
 * @interface Company
 */
export interface Company {
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    unique_name: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    website: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    desk_future_reservation_cutoff: string;
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    desk_today_reservation_time_limit: number;
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    create_date?: string;
}
/**
 * 
 * @export
 * @interface CompanyCreate
 */
export interface CompanyCreate {
    /**
     * 
     * @type {string}
     * @memberof CompanyCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyCreate
     */
    unique_name: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyCreate
     */
    website: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyCreate
     */
    desk_future_reservation_cutoff: string;
    /**
     * 
     * @type {number}
     * @memberof CompanyCreate
     */
    desk_today_reservation_time_limit: number;
}
/**
 * 
 * @export
 * @interface CompanyUpdate
 */
export interface CompanyUpdate {
    /**
     * 
     * @type {string}
     * @memberof CompanyUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyUpdate
     */
    unique_name?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyUpdate
     */
    website?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyUpdate
     */
    desk_future_reservation_cutoff?: string;
    /**
     * 
     * @type {number}
     * @memberof CompanyUpdate
     */
    desk_today_reservation_time_limit?: number;
}
/**
 * 
 * @export
 * @interface CompanyUser
 */
export interface CompanyUser {
    /**
     * 
     * @type {number}
     * @memberof CompanyUser
     */
    company_user_role_id: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyUser
     */
    id?: number;
    /**
     * 
     * @type {Company}
     * @memberof CompanyUser
     */
    company: Company;
    /**
     * 
     * @type {User}
     * @memberof CompanyUser
     */
    user: User;
}
/**
 * 
 * @export
 * @interface CompanyUserCreate
 */
export interface CompanyUserCreate {
    /**
     * 
     * @type {number}
     * @memberof CompanyUserCreate
     */
    company_user_role_id: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyUserCreate
     */
    user_id: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyUserCreate
     */
    company_id: number;
}
/**
 * 
 * @export
 * @interface CompanyUserUpdate
 */
export interface CompanyUserUpdate {
    /**
     * 
     * @type {number}
     * @memberof CompanyUserUpdate
     */
    company_user_role_id?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyUserUpdate
     */
    company_id?: number;
    /**
     * 
     * @type {number}
     * @memberof CompanyUserUpdate
     */
    user_id?: number;
}
/**
 * 
 * @export
 * @interface Desk
 */
export interface Desk {
    /**
     * 
     * @type {string}
     * @memberof Desk
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Desk
     */
    co_ord_x?: number;
    /**
     * 
     * @type {number}
     * @memberof Desk
     */
    co_ord_y?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Desk
     */
    is_out_of_service?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Desk
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof Desk
     */
    create_date: string;
    /**
     * 
     * @type {Floor}
     * @memberof Desk
     */
    floor: Floor;
}
/**
 * 
 * @export
 * @interface DeskCreate
 */
export interface DeskCreate {
    /**
     * 
     * @type {string}
     * @memberof DeskCreate
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof DeskCreate
     */
    co_ord_x?: number;
    /**
     * 
     * @type {number}
     * @memberof DeskCreate
     */
    co_ord_y?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DeskCreate
     */
    is_out_of_service?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DeskCreate
     */
    floor_id: number;
}
/**
 * 
 * @export
 * @interface DeskUpdate
 */
export interface DeskUpdate {
    /**
     * 
     * @type {string}
     * @memberof DeskUpdate
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof DeskUpdate
     */
    co_ord_x?: number;
    /**
     * 
     * @type {number}
     * @memberof DeskUpdate
     */
    co_ord_y?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DeskUpdate
     */
    is_out_of_service?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DeskUpdate
     */
    floor_id?: number;
}
/**
 * 
 * @export
 * @interface Except404
 */
export interface Except404 {
    /**
     * 
     * @type {string}
     * @memberof Except404
     */
    detail?: string;
}
/**
 * 
 * @export
 * @interface ExceptCreateItem409
 */
export interface ExceptCreateItem409 {
    /**
     * 
     * @type {string}
     * @memberof ExceptCreateItem409
     */
    detail?: string;
}
/**
 * 
 * @export
 * @interface ExceptDB400
 */
export interface ExceptDB400 {
    /**
     * 
     * @type {string}
     * @memberof ExceptDB400
     */
    detail?: string;
}
/**
 * 
 * @export
 * @interface Floor
 */
export interface Floor {
    /**
     * 
     * @type {string}
     * @memberof Floor
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Floor
     */
    floor_level: string;
    /**
     * 
     * @type {string}
     * @memberof Floor
     */
    map_image?: string;
    /**
     * 
     * @type {number}
     * @memberof Floor
     */
    map_dimension_x?: number;
    /**
     * 
     * @type {number}
     * @memberof Floor
     */
    map_dimension_y?: number;
    /**
     * 
     * @type {string}
     * @memberof Floor
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof Floor
     */
    create_date?: string;
    /**
     * 
     * @type {Building}
     * @memberof Floor
     */
    building: Building;
}
/**
 * 
 * @export
 * @interface FloorCreate
 */
export interface FloorCreate {
    /**
     * 
     * @type {string}
     * @memberof FloorCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FloorCreate
     */
    floor_level: string;
    /**
     * 
     * @type {string}
     * @memberof FloorCreate
     */
    map_image?: string;
    /**
     * 
     * @type {number}
     * @memberof FloorCreate
     */
    map_dimension_x?: number;
    /**
     * 
     * @type {number}
     * @memberof FloorCreate
     */
    map_dimension_y?: number;
    /**
     * 
     * @type {number}
     * @memberof FloorCreate
     */
    building_id: number;
}
/**
 * 
 * @export
 * @interface FloorUpdate
 */
export interface FloorUpdate {
    /**
     * 
     * @type {string}
     * @memberof FloorUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FloorUpdate
     */
    floor_level?: string;
    /**
     * 
     * @type {string}
     * @memberof FloorUpdate
     */
    map_image?: string;
    /**
     * 
     * @type {number}
     * @memberof FloorUpdate
     */
    map_dimension_x?: number;
    /**
     * 
     * @type {number}
     * @memberof FloorUpdate
     */
    map_dimension_y?: number;
    /**
     * 
     * @type {number}
     * @memberof FloorUpdate
     */
    building_id?: number;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface Msg
 */
export interface Msg {
    /**
     * 
     * @type {string}
     * @memberof Msg
     */
    msg: string;
}
/**
 * 
 * @export
 * @interface Reception
 */
export interface Reception {
    /**
     * 
     * @type {string}
     * @memberof Reception
     */
    reception_name: string;
    /**
     * 
     * @type {number}
     * @memberof Reception
     */
    co_ord_x?: number;
    /**
     * 
     * @type {number}
     * @memberof Reception
     */
    co_ord_y?: number;
    /**
     * 
     * @type {string}
     * @memberof Reception
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof Reception
     */
    create_date?: string;
    /**
     * 
     * @type {Floor}
     * @memberof Reception
     */
    floor: Floor;
}
/**
 * 
 * @export
 * @interface ReceptionCreate
 */
export interface ReceptionCreate {
    /**
     * 
     * @type {string}
     * @memberof ReceptionCreate
     */
    reception_name: string;
    /**
     * 
     * @type {number}
     * @memberof ReceptionCreate
     */
    co_ord_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ReceptionCreate
     */
    co_ord_y?: number;
    /**
     * 
     * @type {number}
     * @memberof ReceptionCreate
     */
    floor_id: number;
}
/**
 * 
 * @export
 * @interface ReceptionUpdate
 */
export interface ReceptionUpdate {
    /**
     * 
     * @type {string}
     * @memberof ReceptionUpdate
     */
    reception_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ReceptionUpdate
     */
    co_ord_x?: number;
    /**
     * 
     * @type {number}
     * @memberof ReceptionUpdate
     */
    co_ord_y?: number;
    /**
     * 
     * @type {number}
     * @memberof ReceptionUpdate
     */
    floor_id?: number;
}
/**
 * 
 * @export
 * @interface Room
 */
export interface Room {
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Room
     */
    co_ord_x?: number;
    /**
     * 
     * @type {number}
     * @memberof Room
     */
    co_ord_y?: number;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    ical_url?: string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    create_date?: string;
    /**
     * 
     * @type {Floor}
     * @memberof Room
     */
    floor: Floor;
}
/**
 * 
 * @export
 * @interface RoomCreate
 */
export interface RoomCreate {
    /**
     * 
     * @type {string}
     * @memberof RoomCreate
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof RoomCreate
     */
    co_ord_x?: number;
    /**
     * 
     * @type {number}
     * @memberof RoomCreate
     */
    co_ord_y?: number;
    /**
     * 
     * @type {string}
     * @memberof RoomCreate
     */
    ical_url?: string;
    /**
     * 
     * @type {number}
     * @memberof RoomCreate
     */
    floor_id: number;
}
/**
 * 
 * @export
 * @interface RoomUpdate
 */
export interface RoomUpdate {
    /**
     * 
     * @type {string}
     * @memberof RoomUpdate
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof RoomUpdate
     */
    co_ord_x?: number;
    /**
     * 
     * @type {number}
     * @memberof RoomUpdate
     */
    co_ord_y?: number;
    /**
     * 
     * @type {string}
     * @memberof RoomUpdate
     */
    ical_url?: string;
    /**
     * 
     * @type {number}
     * @memberof RoomUpdate
     */
    floor_id?: number;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    access_token: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    token_type: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email_address?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    is_active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    is_superuser?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    full_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    whatsapp_number?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    email_address: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreate
     */
    is_active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreate
     */
    is_superuser?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    full_name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    whatsapp_number?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    password: string;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    email_address?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    is_active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    is_superuser?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    full_name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    whatsapp_number?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    loc: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}

/**
 * BuildingsApi - axios parameter creator
 * @export
 */
export const BuildingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a building with all the _name_, _physical_address_, _gps_co_ords_ and _website_.     A unique **slug** for the building will be returned to reference the building via the API.\",     
         * @summary Create a buidling.
         * @param {BuildingCreate} buildingCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuildingApiV1BuildingsPost: async (buildingCreate: BuildingCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'buildingCreate' is not null or undefined
            assertParamExists('createBuildingApiV1BuildingsPost', 'buildingCreate', buildingCreate)
            const localVarPath = `/api/v1/buildings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(buildingCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Building.
         * @summary Delete Building
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuildingApiV1BuildingsSlugDelete: async (slug: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('deleteBuildingApiV1BuildingsSlugDelete', 'slug', slug)
            const localVarPath = `/api/v1/buildings/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Building by ID.
         * @summary Read Building
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readBuildingApiV1BuildingsSlugGet: async (slug: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('readBuildingApiV1BuildingsSlugGet', 'slug', slug)
            const localVarPath = `/api/v1/buildings/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of Buildings.
         * @summary Read Buildings
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readBuildingsApiV1BuildingsGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/buildings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Building.
         * @summary Update Building
         * @param {string} slug 
         * @param {BuildingUpdate} buildingUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuildingApiV1BuildingsSlugPut: async (slug: string, buildingUpdate: BuildingUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('updateBuildingApiV1BuildingsSlugPut', 'slug', slug)
            // verify required parameter 'buildingUpdate' is not null or undefined
            assertParamExists('updateBuildingApiV1BuildingsSlugPut', 'buildingUpdate', buildingUpdate)
            const localVarPath = `/api/v1/buildings/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(buildingUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BuildingsApi - functional programming interface
 * @export
 */
export const BuildingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BuildingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a building with all the _name_, _physical_address_, _gps_co_ords_ and _website_.     A unique **slug** for the building will be returned to reference the building via the API.\",     
         * @summary Create a buidling.
         * @param {BuildingCreate} buildingCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBuildingApiV1BuildingsPost(buildingCreate: BuildingCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Building>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBuildingApiV1BuildingsPost(buildingCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a Building.
         * @summary Delete Building
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBuildingApiV1BuildingsSlugDelete(slug: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBuildingApiV1BuildingsSlugDelete(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Building by ID.
         * @summary Read Building
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readBuildingApiV1BuildingsSlugGet(slug: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Building>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readBuildingApiV1BuildingsSlugGet(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve list of Buildings.
         * @summary Read Buildings
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readBuildingsApiV1BuildingsGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Building>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readBuildingsApiV1BuildingsGet(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Building.
         * @summary Update Building
         * @param {string} slug 
         * @param {BuildingUpdate} buildingUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBuildingApiV1BuildingsSlugPut(slug: string, buildingUpdate: BuildingUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Building>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBuildingApiV1BuildingsSlugPut(slug, buildingUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BuildingsApi - factory interface
 * @export
 */
export const BuildingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BuildingsApiFp(configuration)
    return {
        /**
         * Create a building with all the _name_, _physical_address_, _gps_co_ords_ and _website_.     A unique **slug** for the building will be returned to reference the building via the API.\",     
         * @summary Create a buidling.
         * @param {BuildingCreate} buildingCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuildingApiV1BuildingsPost(buildingCreate: BuildingCreate, options?: any): AxiosPromise<Building> {
            return localVarFp.createBuildingApiV1BuildingsPost(buildingCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Building.
         * @summary Delete Building
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuildingApiV1BuildingsSlugDelete(slug: string, options?: any): AxiosPromise<any> {
            return localVarFp.deleteBuildingApiV1BuildingsSlugDelete(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Building by ID.
         * @summary Read Building
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readBuildingApiV1BuildingsSlugGet(slug: string, options?: any): AxiosPromise<Building> {
            return localVarFp.readBuildingApiV1BuildingsSlugGet(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve list of Buildings.
         * @summary Read Buildings
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readBuildingsApiV1BuildingsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Building>> {
            return localVarFp.readBuildingsApiV1BuildingsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Building.
         * @summary Update Building
         * @param {string} slug 
         * @param {BuildingUpdate} buildingUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuildingApiV1BuildingsSlugPut(slug: string, buildingUpdate: BuildingUpdate, options?: any): AxiosPromise<Building> {
            return localVarFp.updateBuildingApiV1BuildingsSlugPut(slug, buildingUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BuildingsApi - object-oriented interface
 * @export
 * @class BuildingsApi
 * @extends {BaseAPI}
 */
export class BuildingsApi extends BaseAPI {
    /**
     * Create a building with all the _name_, _physical_address_, _gps_co_ords_ and _website_.     A unique **slug** for the building will be returned to reference the building via the API.\",     
     * @summary Create a buidling.
     * @param {BuildingCreate} buildingCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildingsApi
     */
    public createBuildingApiV1BuildingsPost(buildingCreate: BuildingCreate, options?: any) {
        return BuildingsApiFp(this.configuration).createBuildingApiV1BuildingsPost(buildingCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Building.
     * @summary Delete Building
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildingsApi
     */
    public deleteBuildingApiV1BuildingsSlugDelete(slug: string, options?: any) {
        return BuildingsApiFp(this.configuration).deleteBuildingApiV1BuildingsSlugDelete(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Building by ID.
     * @summary Read Building
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildingsApi
     */
    public readBuildingApiV1BuildingsSlugGet(slug: string, options?: any) {
        return BuildingsApiFp(this.configuration).readBuildingApiV1BuildingsSlugGet(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve list of Buildings.
     * @summary Read Buildings
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildingsApi
     */
    public readBuildingsApiV1BuildingsGet(skip?: number, limit?: number, options?: any) {
        return BuildingsApiFp(this.configuration).readBuildingsApiV1BuildingsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Building.
     * @summary Update Building
     * @param {string} slug 
     * @param {BuildingUpdate} buildingUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildingsApi
     */
    public updateBuildingApiV1BuildingsSlugPut(slug: string, buildingUpdate: BuildingUpdate, options?: any) {
        return BuildingsApiFp(this.configuration).updateBuildingApiV1BuildingsSlugPut(slug, buildingUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CompaniesApi - axios parameter creator
 * @export
 */
export const CompaniesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new Company.
         * @summary Create Company
         * @param {CompanyCreate} companyCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompanyApiV1CompaniesPost: async (companyCreate: CompanyCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyCreate' is not null or undefined
            assertParamExists('createCompanyApiV1CompaniesPost', 'companyCreate', companyCreate)
            const localVarPath = `/api/v1/companies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(companyCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a company.
         * @summary Delete Company
         * @param {string} uniqueName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompanyApiV1CompaniesUniqueNameDelete: async (uniqueName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueName' is not null or undefined
            assertParamExists('deleteCompanyApiV1CompaniesUniqueNameDelete', 'uniqueName', uniqueName)
            const localVarPath = `/api/v1/companies/{unique_name}`
                .replace(`{${"unique_name"}}`, encodeURIComponent(String(uniqueName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Companies.
         * @summary Read Companies
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCompaniesApiV1CompaniesGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/companies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Company by ID.
         * @summary Read Company
         * @param {string} uniqueName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCompanyApiV1CompaniesUniqueNameGet: async (uniqueName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueName' is not null or undefined
            assertParamExists('readCompanyApiV1CompaniesUniqueNameGet', 'uniqueName', uniqueName)
            const localVarPath = `/api/v1/companies/{unique_name}`
                .replace(`{${"unique_name"}}`, encodeURIComponent(String(uniqueName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a company.
         * @summary Update Company
         * @param {string} uniqueName 
         * @param {CompanyUpdate} companyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompanyApiV1CompaniesUniqueNamePut: async (uniqueName: string, companyUpdate: CompanyUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueName' is not null or undefined
            assertParamExists('updateCompanyApiV1CompaniesUniqueNamePut', 'uniqueName', uniqueName)
            // verify required parameter 'companyUpdate' is not null or undefined
            assertParamExists('updateCompanyApiV1CompaniesUniqueNamePut', 'companyUpdate', companyUpdate)
            const localVarPath = `/api/v1/companies/{unique_name}`
                .replace(`{${"unique_name"}}`, encodeURIComponent(String(uniqueName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(companyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompaniesApi - functional programming interface
 * @export
 */
export const CompaniesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompaniesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new Company.
         * @summary Create Company
         * @param {CompanyCreate} companyCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCompanyApiV1CompaniesPost(companyCreate: CompanyCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCompanyApiV1CompaniesPost(companyCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a company.
         * @summary Delete Company
         * @param {string} uniqueName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCompanyApiV1CompaniesUniqueNameDelete(uniqueName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCompanyApiV1CompaniesUniqueNameDelete(uniqueName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve Companies.
         * @summary Read Companies
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readCompaniesApiV1CompaniesGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Company>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readCompaniesApiV1CompaniesGet(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Company by ID.
         * @summary Read Company
         * @param {string} uniqueName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readCompanyApiV1CompaniesUniqueNameGet(uniqueName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readCompanyApiV1CompaniesUniqueNameGet(uniqueName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a company.
         * @summary Update Company
         * @param {string} uniqueName 
         * @param {CompanyUpdate} companyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCompanyApiV1CompaniesUniqueNamePut(uniqueName: string, companyUpdate: CompanyUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCompanyApiV1CompaniesUniqueNamePut(uniqueName, companyUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CompaniesApi - factory interface
 * @export
 */
export const CompaniesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompaniesApiFp(configuration)
    return {
        /**
         * Create new Company.
         * @summary Create Company
         * @param {CompanyCreate} companyCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompanyApiV1CompaniesPost(companyCreate: CompanyCreate, options?: any): AxiosPromise<Company> {
            return localVarFp.createCompanyApiV1CompaniesPost(companyCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a company.
         * @summary Delete Company
         * @param {string} uniqueName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompanyApiV1CompaniesUniqueNameDelete(uniqueName: string, options?: any): AxiosPromise<Company> {
            return localVarFp.deleteCompanyApiV1CompaniesUniqueNameDelete(uniqueName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Companies.
         * @summary Read Companies
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCompaniesApiV1CompaniesGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Company>> {
            return localVarFp.readCompaniesApiV1CompaniesGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Company by ID.
         * @summary Read Company
         * @param {string} uniqueName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCompanyApiV1CompaniesUniqueNameGet(uniqueName: string, options?: any): AxiosPromise<Company> {
            return localVarFp.readCompanyApiV1CompaniesUniqueNameGet(uniqueName, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a company.
         * @summary Update Company
         * @param {string} uniqueName 
         * @param {CompanyUpdate} companyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompanyApiV1CompaniesUniqueNamePut(uniqueName: string, companyUpdate: CompanyUpdate, options?: any): AxiosPromise<Company> {
            return localVarFp.updateCompanyApiV1CompaniesUniqueNamePut(uniqueName, companyUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompaniesApi - object-oriented interface
 * @export
 * @class CompaniesApi
 * @extends {BaseAPI}
 */
export class CompaniesApi extends BaseAPI {
    /**
     * Create new Company.
     * @summary Create Company
     * @param {CompanyCreate} companyCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public createCompanyApiV1CompaniesPost(companyCreate: CompanyCreate, options?: any) {
        return CompaniesApiFp(this.configuration).createCompanyApiV1CompaniesPost(companyCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a company.
     * @summary Delete Company
     * @param {string} uniqueName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public deleteCompanyApiV1CompaniesUniqueNameDelete(uniqueName: string, options?: any) {
        return CompaniesApiFp(this.configuration).deleteCompanyApiV1CompaniesUniqueNameDelete(uniqueName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Companies.
     * @summary Read Companies
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public readCompaniesApiV1CompaniesGet(skip?: number, limit?: number, options?: any) {
        return CompaniesApiFp(this.configuration).readCompaniesApiV1CompaniesGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Company by ID.
     * @summary Read Company
     * @param {string} uniqueName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public readCompanyApiV1CompaniesUniqueNameGet(uniqueName: string, options?: any) {
        return CompaniesApiFp(this.configuration).readCompanyApiV1CompaniesUniqueNameGet(uniqueName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a company.
     * @summary Update Company
     * @param {string} uniqueName 
     * @param {CompanyUpdate} companyUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public updateCompanyApiV1CompaniesUniqueNamePut(uniqueName: string, companyUpdate: CompanyUpdate, options?: any) {
        return CompaniesApiFp(this.configuration).updateCompanyApiV1CompaniesUniqueNamePut(uniqueName, companyUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CompanyUsersApi - axios parameter creator
 * @export
 */
export const CompanyUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new Company User.
         * @summary Create Company User
         * @param {CompanyUserCreate} companyUserCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompanyUserApiV1CompanyUsersPost: async (companyUserCreate: CompanyUserCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyUserCreate' is not null or undefined
            assertParamExists('createCompanyUserApiV1CompanyUsersPost', 'companyUserCreate', companyUserCreate)
            const localVarPath = `/api/v1/company_users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(companyUserCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a company user.
         * @summary Delete Company User
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompanyUserApiV1CompanyUsersIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCompanyUserApiV1CompanyUsersIdDelete', 'id', id)
            const localVarPath = `/api/v1/company_users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Compnay user by ID.
         * @summary Read Company User
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCompanyUserApiV1CompanyUsersIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readCompanyUserApiV1CompanyUsersIdGet', 'id', id)
            const localVarPath = `/api/v1/company_users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Company User by User ID.
         * @summary Read Company User By Company Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCompanyUserByCompanyIdApiV1CompanyUsersCompanyIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readCompanyUserByCompanyIdApiV1CompanyUsersCompanyIdGet', 'id', id)
            const localVarPath = `/api/v1/company_users/company/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Company User by User ID.
         * @summary Read Company User By User Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCompanyUserByUserIdApiV1CompanyUsersUserIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readCompanyUserByUserIdApiV1CompanyUsersUserIdGet', 'id', id)
            const localVarPath = `/api/v1/company_users/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Company Users.
         * @summary Read Company Users
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCompanyUsersApiV1CompanyUsersGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/company_users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a company user.
         * @summary Update Company
         * @param {number} id 
         * @param {CompanyUserUpdate} companyUserUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompanyApiV1CompanyUsersIdPut: async (id: number, companyUserUpdate: CompanyUserUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCompanyApiV1CompanyUsersIdPut', 'id', id)
            // verify required parameter 'companyUserUpdate' is not null or undefined
            assertParamExists('updateCompanyApiV1CompanyUsersIdPut', 'companyUserUpdate', companyUserUpdate)
            const localVarPath = `/api/v1/company_users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(companyUserUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyUsersApi - functional programming interface
 * @export
 */
export const CompanyUsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompanyUsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new Company User.
         * @summary Create Company User
         * @param {CompanyUserCreate} companyUserCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCompanyUserApiV1CompanyUsersPost(companyUserCreate: CompanyUserCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCompanyUserApiV1CompanyUsersPost(companyUserCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a company user.
         * @summary Delete Company User
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCompanyUserApiV1CompanyUsersIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCompanyUserApiV1CompanyUsersIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Compnay user by ID.
         * @summary Read Company User
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readCompanyUserApiV1CompanyUsersIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readCompanyUserApiV1CompanyUsersIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Company User by User ID.
         * @summary Read Company User By Company Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readCompanyUserByCompanyIdApiV1CompanyUsersCompanyIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CompanyUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readCompanyUserByCompanyIdApiV1CompanyUsersCompanyIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Company User by User ID.
         * @summary Read Company User By User Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readCompanyUserByUserIdApiV1CompanyUsersUserIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CompanyUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readCompanyUserByUserIdApiV1CompanyUsersUserIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve Company Users.
         * @summary Read Company Users
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readCompanyUsersApiV1CompanyUsersGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CompanyUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readCompanyUsersApiV1CompanyUsersGet(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a company user.
         * @summary Update Company
         * @param {number} id 
         * @param {CompanyUserUpdate} companyUserUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCompanyApiV1CompanyUsersIdPut(id: number, companyUserUpdate: CompanyUserUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCompanyApiV1CompanyUsersIdPut(id, companyUserUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CompanyUsersApi - factory interface
 * @export
 */
export const CompanyUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompanyUsersApiFp(configuration)
    return {
        /**
         * Create new Company User.
         * @summary Create Company User
         * @param {CompanyUserCreate} companyUserCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompanyUserApiV1CompanyUsersPost(companyUserCreate: CompanyUserCreate, options?: any): AxiosPromise<CompanyUser> {
            return localVarFp.createCompanyUserApiV1CompanyUsersPost(companyUserCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a company user.
         * @summary Delete Company User
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompanyUserApiV1CompanyUsersIdDelete(id: number, options?: any): AxiosPromise<CompanyUser> {
            return localVarFp.deleteCompanyUserApiV1CompanyUsersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Compnay user by ID.
         * @summary Read Company User
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCompanyUserApiV1CompanyUsersIdGet(id: number, options?: any): AxiosPromise<CompanyUser> {
            return localVarFp.readCompanyUserApiV1CompanyUsersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Company User by User ID.
         * @summary Read Company User By Company Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCompanyUserByCompanyIdApiV1CompanyUsersCompanyIdGet(id: number, options?: any): AxiosPromise<Array<CompanyUser>> {
            return localVarFp.readCompanyUserByCompanyIdApiV1CompanyUsersCompanyIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Company User by User ID.
         * @summary Read Company User By User Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCompanyUserByUserIdApiV1CompanyUsersUserIdGet(id: number, options?: any): AxiosPromise<Array<CompanyUser>> {
            return localVarFp.readCompanyUserByUserIdApiV1CompanyUsersUserIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Company Users.
         * @summary Read Company Users
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCompanyUsersApiV1CompanyUsersGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<CompanyUser>> {
            return localVarFp.readCompanyUsersApiV1CompanyUsersGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a company user.
         * @summary Update Company
         * @param {number} id 
         * @param {CompanyUserUpdate} companyUserUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompanyApiV1CompanyUsersIdPut(id: number, companyUserUpdate: CompanyUserUpdate, options?: any): AxiosPromise<CompanyUser> {
            return localVarFp.updateCompanyApiV1CompanyUsersIdPut(id, companyUserUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompanyUsersApi - object-oriented interface
 * @export
 * @class CompanyUsersApi
 * @extends {BaseAPI}
 */
export class CompanyUsersApi extends BaseAPI {
    /**
     * Create new Company User.
     * @summary Create Company User
     * @param {CompanyUserCreate} companyUserCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyUsersApi
     */
    public createCompanyUserApiV1CompanyUsersPost(companyUserCreate: CompanyUserCreate, options?: any) {
        return CompanyUsersApiFp(this.configuration).createCompanyUserApiV1CompanyUsersPost(companyUserCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a company user.
     * @summary Delete Company User
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyUsersApi
     */
    public deleteCompanyUserApiV1CompanyUsersIdDelete(id: number, options?: any) {
        return CompanyUsersApiFp(this.configuration).deleteCompanyUserApiV1CompanyUsersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Compnay user by ID.
     * @summary Read Company User
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyUsersApi
     */
    public readCompanyUserApiV1CompanyUsersIdGet(id: number, options?: any) {
        return CompanyUsersApiFp(this.configuration).readCompanyUserApiV1CompanyUsersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Company User by User ID.
     * @summary Read Company User By Company Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyUsersApi
     */
    public readCompanyUserByCompanyIdApiV1CompanyUsersCompanyIdGet(id: number, options?: any) {
        return CompanyUsersApiFp(this.configuration).readCompanyUserByCompanyIdApiV1CompanyUsersCompanyIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Company User by User ID.
     * @summary Read Company User By User Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyUsersApi
     */
    public readCompanyUserByUserIdApiV1CompanyUsersUserIdGet(id: number, options?: any) {
        return CompanyUsersApiFp(this.configuration).readCompanyUserByUserIdApiV1CompanyUsersUserIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Company Users.
     * @summary Read Company Users
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyUsersApi
     */
    public readCompanyUsersApiV1CompanyUsersGet(skip?: number, limit?: number, options?: any) {
        return CompanyUsersApiFp(this.configuration).readCompanyUsersApiV1CompanyUsersGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a company user.
     * @summary Update Company
     * @param {number} id 
     * @param {CompanyUserUpdate} companyUserUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyUsersApi
     */
    public updateCompanyApiV1CompanyUsersIdPut(id: number, companyUserUpdate: CompanyUserUpdate, options?: any) {
        return CompanyUsersApiFp(this.configuration).updateCompanyApiV1CompanyUsersIdPut(id, companyUserUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Read Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readRootGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Read Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readRootGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readRootGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Read Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readRootGet(options?: any): AxiosPromise<any> {
            return localVarFp.readRootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Read Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public readRootGet(options?: any) {
        return DefaultApiFp(this.configuration).readRootGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DesksApi - axios parameter creator
 * @export
 */
export const DesksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new Desk.
         * @summary Create Desk
         * @param {DeskCreate} deskCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeskApiV1DesksPost: async (deskCreate: DeskCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deskCreate' is not null or undefined
            assertParamExists('createDeskApiV1DesksPost', 'deskCreate', deskCreate)
            const localVarPath = `/api/v1/desks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deskCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Desk.
         * @summary Delete Desk
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeskApiV1DesksSlugDelete: async (slug: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('deleteDeskApiV1DesksSlugDelete', 'slug', slug)
            const localVarPath = `/api/v1/desks/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Desk by ID.
         * @summary Read Desk
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDeskApiV1DesksSlugGet: async (slug: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('readDeskApiV1DesksSlugGet', 'slug', slug)
            const localVarPath = `/api/v1/desks/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of Desks.
         * @summary Read Desks
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDesksApiV1DesksGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/desks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Desk.
         * @summary Update Desk
         * @param {string} slug 
         * @param {DeskUpdate} deskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeskApiV1DesksSlugPut: async (slug: string, deskUpdate: DeskUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('updateDeskApiV1DesksSlugPut', 'slug', slug)
            // verify required parameter 'deskUpdate' is not null or undefined
            assertParamExists('updateDeskApiV1DesksSlugPut', 'deskUpdate', deskUpdate)
            const localVarPath = `/api/v1/desks/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deskUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DesksApi - functional programming interface
 * @export
 */
export const DesksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DesksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new Desk.
         * @summary Create Desk
         * @param {DeskCreate} deskCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeskApiV1DesksPost(deskCreate: DeskCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Desk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeskApiV1DesksPost(deskCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a Desk.
         * @summary Delete Desk
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeskApiV1DesksSlugDelete(slug: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeskApiV1DesksSlugDelete(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Desk by ID.
         * @summary Read Desk
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readDeskApiV1DesksSlugGet(slug: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Desk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readDeskApiV1DesksSlugGet(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve list of Desks.
         * @summary Read Desks
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readDesksApiV1DesksGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Desk>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readDesksApiV1DesksGet(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Desk.
         * @summary Update Desk
         * @param {string} slug 
         * @param {DeskUpdate} deskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeskApiV1DesksSlugPut(slug: string, deskUpdate: DeskUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Desk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeskApiV1DesksSlugPut(slug, deskUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DesksApi - factory interface
 * @export
 */
export const DesksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DesksApiFp(configuration)
    return {
        /**
         * Create new Desk.
         * @summary Create Desk
         * @param {DeskCreate} deskCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeskApiV1DesksPost(deskCreate: DeskCreate, options?: any): AxiosPromise<Desk> {
            return localVarFp.createDeskApiV1DesksPost(deskCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Desk.
         * @summary Delete Desk
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeskApiV1DesksSlugDelete(slug: string, options?: any): AxiosPromise<any> {
            return localVarFp.deleteDeskApiV1DesksSlugDelete(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Desk by ID.
         * @summary Read Desk
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDeskApiV1DesksSlugGet(slug: string, options?: any): AxiosPromise<Desk> {
            return localVarFp.readDeskApiV1DesksSlugGet(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve list of Desks.
         * @summary Read Desks
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDesksApiV1DesksGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Desk>> {
            return localVarFp.readDesksApiV1DesksGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Desk.
         * @summary Update Desk
         * @param {string} slug 
         * @param {DeskUpdate} deskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeskApiV1DesksSlugPut(slug: string, deskUpdate: DeskUpdate, options?: any): AxiosPromise<Desk> {
            return localVarFp.updateDeskApiV1DesksSlugPut(slug, deskUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DesksApi - object-oriented interface
 * @export
 * @class DesksApi
 * @extends {BaseAPI}
 */
export class DesksApi extends BaseAPI {
    /**
     * Create new Desk.
     * @summary Create Desk
     * @param {DeskCreate} deskCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DesksApi
     */
    public createDeskApiV1DesksPost(deskCreate: DeskCreate, options?: any) {
        return DesksApiFp(this.configuration).createDeskApiV1DesksPost(deskCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Desk.
     * @summary Delete Desk
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DesksApi
     */
    public deleteDeskApiV1DesksSlugDelete(slug: string, options?: any) {
        return DesksApiFp(this.configuration).deleteDeskApiV1DesksSlugDelete(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Desk by ID.
     * @summary Read Desk
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DesksApi
     */
    public readDeskApiV1DesksSlugGet(slug: string, options?: any) {
        return DesksApiFp(this.configuration).readDeskApiV1DesksSlugGet(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve list of Desks.
     * @summary Read Desks
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DesksApi
     */
    public readDesksApiV1DesksGet(skip?: number, limit?: number, options?: any) {
        return DesksApiFp(this.configuration).readDesksApiV1DesksGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Desk.
     * @summary Update Desk
     * @param {string} slug 
     * @param {DeskUpdate} deskUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DesksApi
     */
    public updateDeskApiV1DesksSlugPut(slug: string, deskUpdate: DeskUpdate, options?: any) {
        return DesksApiFp(this.configuration).updateDeskApiV1DesksSlugPut(slug, deskUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FloorsApi - axios parameter creator
 * @export
 */
export const FloorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new Floor.
         * @summary Create Floor
         * @param {FloorCreate} floorCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFloorApiV1FloorsPost: async (floorCreate: FloorCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'floorCreate' is not null or undefined
            assertParamExists('createFloorApiV1FloorsPost', 'floorCreate', floorCreate)
            const localVarPath = `/api/v1/floors/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(floorCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Floor.
         * @summary Delete Floor
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFloorApiV1FloorsSlugDelete: async (slug: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('deleteFloorApiV1FloorsSlugDelete', 'slug', slug)
            const localVarPath = `/api/v1/floors/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Floor by ID.
         * @summary Read Floor
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readFloorApiV1FloorsSlugGet: async (slug: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('readFloorApiV1FloorsSlugGet', 'slug', slug)
            const localVarPath = `/api/v1/floors/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of Floors.
         * @summary Read Floors
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readFloorsApiV1FloorsGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/floors/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Floor.
         * @summary Update Floor
         * @param {string} slug 
         * @param {FloorUpdate} floorUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFloorApiV1FloorsSlugPut: async (slug: string, floorUpdate: FloorUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('updateFloorApiV1FloorsSlugPut', 'slug', slug)
            // verify required parameter 'floorUpdate' is not null or undefined
            assertParamExists('updateFloorApiV1FloorsSlugPut', 'floorUpdate', floorUpdate)
            const localVarPath = `/api/v1/floors/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(floorUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FloorsApi - functional programming interface
 * @export
 */
export const FloorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FloorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new Floor.
         * @summary Create Floor
         * @param {FloorCreate} floorCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFloorApiV1FloorsPost(floorCreate: FloorCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Floor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFloorApiV1FloorsPost(floorCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a Floor.
         * @summary Delete Floor
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFloorApiV1FloorsSlugDelete(slug: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFloorApiV1FloorsSlugDelete(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Floor by ID.
         * @summary Read Floor
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readFloorApiV1FloorsSlugGet(slug: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Floor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readFloorApiV1FloorsSlugGet(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve list of Floors.
         * @summary Read Floors
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readFloorsApiV1FloorsGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Floor>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readFloorsApiV1FloorsGet(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Floor.
         * @summary Update Floor
         * @param {string} slug 
         * @param {FloorUpdate} floorUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFloorApiV1FloorsSlugPut(slug: string, floorUpdate: FloorUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Floor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFloorApiV1FloorsSlugPut(slug, floorUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FloorsApi - factory interface
 * @export
 */
export const FloorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FloorsApiFp(configuration)
    return {
        /**
         * Create new Floor.
         * @summary Create Floor
         * @param {FloorCreate} floorCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFloorApiV1FloorsPost(floorCreate: FloorCreate, options?: any): AxiosPromise<Floor> {
            return localVarFp.createFloorApiV1FloorsPost(floorCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Floor.
         * @summary Delete Floor
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFloorApiV1FloorsSlugDelete(slug: string, options?: any): AxiosPromise<any> {
            return localVarFp.deleteFloorApiV1FloorsSlugDelete(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Floor by ID.
         * @summary Read Floor
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readFloorApiV1FloorsSlugGet(slug: string, options?: any): AxiosPromise<Floor> {
            return localVarFp.readFloorApiV1FloorsSlugGet(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve list of Floors.
         * @summary Read Floors
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readFloorsApiV1FloorsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Floor>> {
            return localVarFp.readFloorsApiV1FloorsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Floor.
         * @summary Update Floor
         * @param {string} slug 
         * @param {FloorUpdate} floorUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFloorApiV1FloorsSlugPut(slug: string, floorUpdate: FloorUpdate, options?: any): AxiosPromise<Floor> {
            return localVarFp.updateFloorApiV1FloorsSlugPut(slug, floorUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FloorsApi - object-oriented interface
 * @export
 * @class FloorsApi
 * @extends {BaseAPI}
 */
export class FloorsApi extends BaseAPI {
    /**
     * Create new Floor.
     * @summary Create Floor
     * @param {FloorCreate} floorCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloorsApi
     */
    public createFloorApiV1FloorsPost(floorCreate: FloorCreate, options?: any) {
        return FloorsApiFp(this.configuration).createFloorApiV1FloorsPost(floorCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Floor.
     * @summary Delete Floor
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloorsApi
     */
    public deleteFloorApiV1FloorsSlugDelete(slug: string, options?: any) {
        return FloorsApiFp(this.configuration).deleteFloorApiV1FloorsSlugDelete(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Floor by ID.
     * @summary Read Floor
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloorsApi
     */
    public readFloorApiV1FloorsSlugGet(slug: string, options?: any) {
        return FloorsApiFp(this.configuration).readFloorApiV1FloorsSlugGet(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve list of Floors.
     * @summary Read Floors
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloorsApi
     */
    public readFloorsApiV1FloorsGet(skip?: number, limit?: number, options?: any) {
        return FloorsApiFp(this.configuration).readFloorsApiV1FloorsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Floor.
     * @summary Update Floor
     * @param {string} slug 
     * @param {FloorUpdate} floorUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloorsApi
     */
    public updateFloorApiV1FloorsSlugPut(slug: string, floorUpdate: FloorUpdate, options?: any) {
        return FloorsApiFp(this.configuration).updateFloorApiV1FloorsSlugPut(slug, floorUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginApi - axios parameter creator
 * @export
 */
export const LoginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests
         * @summary Login Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAccessTokenApiV1LoginAccessTokenPost: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginAccessTokenApiV1LoginAccessTokenPost', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginAccessTokenApiV1LoginAccessTokenPost', 'password', password)
            const localVarPath = `/api/v1/login/access-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Password Recovery
         * @summary Recover Password
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPasswordApiV1PasswordRecoveryEmailPost: async (email: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('recoverPasswordApiV1PasswordRecoveryEmailPost', 'email', email)
            const localVarPath = `/api/v1/password-recovery/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset password
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1ResetPasswordPost} bodyResetPasswordApiV1ResetPasswordPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordApiV1ResetPasswordPost: async (bodyResetPasswordApiV1ResetPasswordPost: BodyResetPasswordApiV1ResetPasswordPost, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyResetPasswordApiV1ResetPasswordPost' is not null or undefined
            assertParamExists('resetPasswordApiV1ResetPasswordPost', 'bodyResetPasswordApiV1ResetPasswordPost', bodyResetPasswordApiV1ResetPasswordPost)
            const localVarPath = `/api/v1/reset-password/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyResetPasswordApiV1ResetPasswordPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test access token
         * @summary Test Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testTokenApiV1LoginTestTokenPost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/login/test-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoginApiAxiosParamCreator(configuration)
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests
         * @summary Login Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAccessTokenApiV1LoginAccessTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAccessTokenApiV1LoginAccessTokenPost(username, password, grantType, scope, clientId, clientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Password Recovery
         * @summary Recover Password
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverPasswordApiV1PasswordRecoveryEmailPost(email: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Msg>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoverPasswordApiV1PasswordRecoveryEmailPost(email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset password
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1ResetPasswordPost} bodyResetPasswordApiV1ResetPasswordPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost: BodyResetPasswordApiV1ResetPasswordPost, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Msg>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test access token
         * @summary Test Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testTokenApiV1LoginTestTokenPost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testTokenApiV1LoginTestTokenPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoginApiFp(configuration)
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests
         * @summary Login Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAccessTokenApiV1LoginAccessTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<Token> {
            return localVarFp.loginAccessTokenApiV1LoginAccessTokenPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Password Recovery
         * @summary Recover Password
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverPasswordApiV1PasswordRecoveryEmailPost(email: string, options?: any): AxiosPromise<Msg> {
            return localVarFp.recoverPasswordApiV1PasswordRecoveryEmailPost(email, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset password
         * @summary Reset Password
         * @param {BodyResetPasswordApiV1ResetPasswordPost} bodyResetPasswordApiV1ResetPasswordPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost: BodyResetPasswordApiV1ResetPasswordPost, options?: any): AxiosPromise<Msg> {
            return localVarFp.resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Test access token
         * @summary Test Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testTokenApiV1LoginTestTokenPost(options?: any): AxiosPromise<User> {
            return localVarFp.testTokenApiV1LoginTestTokenPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI {
    /**
     * OAuth2 compatible token login, get an access token for future requests
     * @summary Login Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public loginAccessTokenApiV1LoginAccessTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any) {
        return LoginApiFp(this.configuration).loginAccessTokenApiV1LoginAccessTokenPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Password Recovery
     * @summary Recover Password
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public recoverPasswordApiV1PasswordRecoveryEmailPost(email: string, options?: any) {
        return LoginApiFp(this.configuration).recoverPasswordApiV1PasswordRecoveryEmailPost(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset password
     * @summary Reset Password
     * @param {BodyResetPasswordApiV1ResetPasswordPost} bodyResetPasswordApiV1ResetPasswordPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost: BodyResetPasswordApiV1ResetPasswordPost, options?: any) {
        return LoginApiFp(this.configuration).resetPasswordApiV1ResetPasswordPost(bodyResetPasswordApiV1ResetPasswordPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test access token
     * @summary Test Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public testTokenApiV1LoginTestTokenPost(options?: any) {
        return LoginApiFp(this.configuration).testTokenApiV1LoginTestTokenPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReceptionsApi - axios parameter creator
 * @export
 */
export const ReceptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new Reception.
         * @summary Create Reception
         * @param {ReceptionCreate} receptionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReceptionApiV1ReceptionsPost: async (receptionCreate: ReceptionCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'receptionCreate' is not null or undefined
            assertParamExists('createReceptionApiV1ReceptionsPost', 'receptionCreate', receptionCreate)
            const localVarPath = `/api/v1/receptions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(receptionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Reception.
         * @summary Delete Reception
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReceptionApiV1ReceptionsSlugDelete: async (slug: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('deleteReceptionApiV1ReceptionsSlugDelete', 'slug', slug)
            const localVarPath = `/api/v1/receptions/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Reception by ID.
         * @summary Read Reception
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readReceptionApiV1ReceptionsSlugGet: async (slug: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('readReceptionApiV1ReceptionsSlugGet', 'slug', slug)
            const localVarPath = `/api/v1/receptions/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of receptions.
         * @summary Read Receptions
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readReceptionsApiV1ReceptionsGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/receptions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Reception.
         * @summary Update Reception
         * @param {string} slug 
         * @param {ReceptionUpdate} receptionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReceptionApiV1ReceptionsSlugPut: async (slug: string, receptionUpdate: ReceptionUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('updateReceptionApiV1ReceptionsSlugPut', 'slug', slug)
            // verify required parameter 'receptionUpdate' is not null or undefined
            assertParamExists('updateReceptionApiV1ReceptionsSlugPut', 'receptionUpdate', receptionUpdate)
            const localVarPath = `/api/v1/receptions/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(receptionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReceptionsApi - functional programming interface
 * @export
 */
export const ReceptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReceptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new Reception.
         * @summary Create Reception
         * @param {ReceptionCreate} receptionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReceptionApiV1ReceptionsPost(receptionCreate: ReceptionCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reception>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReceptionApiV1ReceptionsPost(receptionCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a Reception.
         * @summary Delete Reception
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReceptionApiV1ReceptionsSlugDelete(slug: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReceptionApiV1ReceptionsSlugDelete(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Reception by ID.
         * @summary Read Reception
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readReceptionApiV1ReceptionsSlugGet(slug: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reception>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readReceptionApiV1ReceptionsSlugGet(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve list of receptions.
         * @summary Read Receptions
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readReceptionsApiV1ReceptionsGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reception>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readReceptionsApiV1ReceptionsGet(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Reception.
         * @summary Update Reception
         * @param {string} slug 
         * @param {ReceptionUpdate} receptionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReceptionApiV1ReceptionsSlugPut(slug: string, receptionUpdate: ReceptionUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reception>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReceptionApiV1ReceptionsSlugPut(slug, receptionUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReceptionsApi - factory interface
 * @export
 */
export const ReceptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReceptionsApiFp(configuration)
    return {
        /**
         * Create new Reception.
         * @summary Create Reception
         * @param {ReceptionCreate} receptionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReceptionApiV1ReceptionsPost(receptionCreate: ReceptionCreate, options?: any): AxiosPromise<Reception> {
            return localVarFp.createReceptionApiV1ReceptionsPost(receptionCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Reception.
         * @summary Delete Reception
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReceptionApiV1ReceptionsSlugDelete(slug: string, options?: any): AxiosPromise<any> {
            return localVarFp.deleteReceptionApiV1ReceptionsSlugDelete(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Reception by ID.
         * @summary Read Reception
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readReceptionApiV1ReceptionsSlugGet(slug: string, options?: any): AxiosPromise<Reception> {
            return localVarFp.readReceptionApiV1ReceptionsSlugGet(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve list of receptions.
         * @summary Read Receptions
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readReceptionsApiV1ReceptionsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Reception>> {
            return localVarFp.readReceptionsApiV1ReceptionsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Reception.
         * @summary Update Reception
         * @param {string} slug 
         * @param {ReceptionUpdate} receptionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReceptionApiV1ReceptionsSlugPut(slug: string, receptionUpdate: ReceptionUpdate, options?: any): AxiosPromise<Reception> {
            return localVarFp.updateReceptionApiV1ReceptionsSlugPut(slug, receptionUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReceptionsApi - object-oriented interface
 * @export
 * @class ReceptionsApi
 * @extends {BaseAPI}
 */
export class ReceptionsApi extends BaseAPI {
    /**
     * Create new Reception.
     * @summary Create Reception
     * @param {ReceptionCreate} receptionCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceptionsApi
     */
    public createReceptionApiV1ReceptionsPost(receptionCreate: ReceptionCreate, options?: any) {
        return ReceptionsApiFp(this.configuration).createReceptionApiV1ReceptionsPost(receptionCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Reception.
     * @summary Delete Reception
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceptionsApi
     */
    public deleteReceptionApiV1ReceptionsSlugDelete(slug: string, options?: any) {
        return ReceptionsApiFp(this.configuration).deleteReceptionApiV1ReceptionsSlugDelete(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Reception by ID.
     * @summary Read Reception
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceptionsApi
     */
    public readReceptionApiV1ReceptionsSlugGet(slug: string, options?: any) {
        return ReceptionsApiFp(this.configuration).readReceptionApiV1ReceptionsSlugGet(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve list of receptions.
     * @summary Read Receptions
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceptionsApi
     */
    public readReceptionsApiV1ReceptionsGet(skip?: number, limit?: number, options?: any) {
        return ReceptionsApiFp(this.configuration).readReceptionsApiV1ReceptionsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Reception.
     * @summary Update Reception
     * @param {string} slug 
     * @param {ReceptionUpdate} receptionUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceptionsApi
     */
    public updateReceptionApiV1ReceptionsSlugPut(slug: string, receptionUpdate: ReceptionUpdate, options?: any) {
        return ReceptionsApiFp(this.configuration).updateReceptionApiV1ReceptionsSlugPut(slug, receptionUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RoomsApi - axios parameter creator
 * @export
 */
export const RoomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new Room.
         * @summary Create Room
         * @param {RoomCreate} roomCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoomApiV1RoomsPost: async (roomCreate: RoomCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomCreate' is not null or undefined
            assertParamExists('createRoomApiV1RoomsPost', 'roomCreate', roomCreate)
            const localVarPath = `/api/v1/rooms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roomCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Room.
         * @summary Delete Room
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoomApiV1RoomsSlugDelete: async (slug: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('deleteRoomApiV1RoomsSlugDelete', 'slug', slug)
            const localVarPath = `/api/v1/rooms/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Room by ID.
         * @summary Read Room
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readRoomApiV1RoomsSlugGet: async (slug: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('readRoomApiV1RoomsSlugGet', 'slug', slug)
            const localVarPath = `/api/v1/rooms/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of rooms.
         * @summary Read Rooms
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readRoomsApiV1RoomsGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/rooms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Room.
         * @summary Update Room
         * @param {string} slug 
         * @param {RoomUpdate} roomUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoomApiV1RoomsSlugPut: async (slug: string, roomUpdate: RoomUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('updateRoomApiV1RoomsSlugPut', 'slug', slug)
            // verify required parameter 'roomUpdate' is not null or undefined
            assertParamExists('updateRoomApiV1RoomsSlugPut', 'roomUpdate', roomUpdate)
            const localVarPath = `/api/v1/rooms/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roomUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomsApi - functional programming interface
 * @export
 */
export const RoomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new Room.
         * @summary Create Room
         * @param {RoomCreate} roomCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoomApiV1RoomsPost(roomCreate: RoomCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Room>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoomApiV1RoomsPost(roomCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a Room.
         * @summary Delete Room
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoomApiV1RoomsSlugDelete(slug: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoomApiV1RoomsSlugDelete(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Room by ID.
         * @summary Read Room
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readRoomApiV1RoomsSlugGet(slug: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Room>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readRoomApiV1RoomsSlugGet(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve list of rooms.
         * @summary Read Rooms
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readRoomsApiV1RoomsGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Room>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readRoomsApiV1RoomsGet(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Room.
         * @summary Update Room
         * @param {string} slug 
         * @param {RoomUpdate} roomUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoomApiV1RoomsSlugPut(slug: string, roomUpdate: RoomUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Room>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRoomApiV1RoomsSlugPut(slug, roomUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RoomsApi - factory interface
 * @export
 */
export const RoomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomsApiFp(configuration)
    return {
        /**
         * Create new Room.
         * @summary Create Room
         * @param {RoomCreate} roomCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoomApiV1RoomsPost(roomCreate: RoomCreate, options?: any): AxiosPromise<Room> {
            return localVarFp.createRoomApiV1RoomsPost(roomCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Room.
         * @summary Delete Room
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoomApiV1RoomsSlugDelete(slug: string, options?: any): AxiosPromise<any> {
            return localVarFp.deleteRoomApiV1RoomsSlugDelete(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Room by ID.
         * @summary Read Room
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readRoomApiV1RoomsSlugGet(slug: string, options?: any): AxiosPromise<Room> {
            return localVarFp.readRoomApiV1RoomsSlugGet(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve list of rooms.
         * @summary Read Rooms
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readRoomsApiV1RoomsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Room>> {
            return localVarFp.readRoomsApiV1RoomsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Room.
         * @summary Update Room
         * @param {string} slug 
         * @param {RoomUpdate} roomUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoomApiV1RoomsSlugPut(slug: string, roomUpdate: RoomUpdate, options?: any): AxiosPromise<Room> {
            return localVarFp.updateRoomApiV1RoomsSlugPut(slug, roomUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomsApi - object-oriented interface
 * @export
 * @class RoomsApi
 * @extends {BaseAPI}
 */
export class RoomsApi extends BaseAPI {
    /**
     * Create new Room.
     * @summary Create Room
     * @param {RoomCreate} roomCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public createRoomApiV1RoomsPost(roomCreate: RoomCreate, options?: any) {
        return RoomsApiFp(this.configuration).createRoomApiV1RoomsPost(roomCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Room.
     * @summary Delete Room
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public deleteRoomApiV1RoomsSlugDelete(slug: string, options?: any) {
        return RoomsApiFp(this.configuration).deleteRoomApiV1RoomsSlugDelete(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Room by ID.
     * @summary Read Room
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public readRoomApiV1RoomsSlugGet(slug: string, options?: any) {
        return RoomsApiFp(this.configuration).readRoomApiV1RoomsSlugGet(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve list of rooms.
     * @summary Read Rooms
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public readRoomsApiV1RoomsGet(skip?: number, limit?: number, options?: any) {
        return RoomsApiFp(this.configuration).readRoomsApiV1RoomsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Room.
     * @summary Update Room
     * @param {string} slug 
     * @param {RoomUpdate} roomUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public updateRoomApiV1RoomsSlugPut(slug: string, roomUpdate: RoomUpdate, options?: any) {
        return RoomsApiFp(this.configuration).updateRoomApiV1RoomsSlugPut(slug, roomUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new user.
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserApiV1UsersPost: async (userCreate: UserCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('createUserApiV1UsersPost', 'userCreate', userCreate)
            const localVarPath = `/api/v1/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new user without the need to be logged in.
         * @summary Create User Open
         * @param {BodyCreateUserOpenApiV1UsersOpenPost} bodyCreateUserOpenApiV1UsersOpenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserOpenApiV1UsersOpenPost: async (bodyCreateUserOpenApiV1UsersOpenPost: BodyCreateUserOpenApiV1UsersOpenPost, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateUserOpenApiV1UsersOpenPost' is not null or undefined
            assertParamExists('createUserOpenApiV1UsersOpenPost', 'bodyCreateUserOpenApiV1UsersOpenPost', bodyCreateUserOpenApiV1UsersOpenPost)
            const localVarPath = `/api/v1/users/open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyCreateUserOpenApiV1UsersOpenPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific user by id.
         * @summary Read User By Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserByIdApiV1UsersUserIdGet: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('readUserByIdApiV1UsersUserIdGet', 'userId', userId)
            const localVarPath = `/api/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user.
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserMeApiV1UsersMeGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve users.
         * @summary Read Users
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsersApiV1UsersGet: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user.
         * @summary Update User
         * @param {number} userId 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserApiV1UsersUserIdPut: async (userId: number, userUpdate: UserUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserApiV1UsersUserIdPut', 'userId', userId)
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('updateUserApiV1UsersUserIdPut', 'userUpdate', userUpdate)
            const localVarPath = `/api/v1/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update own user.
         * @summary Update User Me
         * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserMeApiV1UsersMePut: async (bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyUpdateUserMeApiV1UsersMePut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new user.
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserApiV1UsersPost(userCreate: UserCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserApiV1UsersPost(userCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new user without the need to be logged in.
         * @summary Create User Open
         * @param {BodyCreateUserOpenApiV1UsersOpenPost} bodyCreateUserOpenApiV1UsersOpenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost: BodyCreateUserOpenApiV1UsersOpenPost, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a specific user by id.
         * @summary Read User By Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUserByIdApiV1UsersUserIdGet(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUserByIdApiV1UsersUserIdGet(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current user.
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUserMeApiV1UsersMeGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUserMeApiV1UsersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve users.
         * @summary Read Users
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUsersApiV1UsersGet(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUsersApiV1UsersGet(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a user.
         * @summary Update User
         * @param {number} userId 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserApiV1UsersUserIdPut(userId: number, userUpdate: UserUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserApiV1UsersUserIdPut(userId, userUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update own user.
         * @summary Update User Me
         * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Create new user.
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserApiV1UsersPost(userCreate: UserCreate, options?: any): AxiosPromise<User> {
            return localVarFp.createUserApiV1UsersPost(userCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new user without the need to be logged in.
         * @summary Create User Open
         * @param {BodyCreateUserOpenApiV1UsersOpenPost} bodyCreateUserOpenApiV1UsersOpenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost: BodyCreateUserOpenApiV1UsersOpenPost, options?: any): AxiosPromise<User> {
            return localVarFp.createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific user by id.
         * @summary Read User By Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserByIdApiV1UsersUserIdGet(userId: number, options?: any): AxiosPromise<User> {
            return localVarFp.readUserByIdApiV1UsersUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user.
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserMeApiV1UsersMeGet(options?: any): AxiosPromise<User> {
            return localVarFp.readUserMeApiV1UsersMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve users.
         * @summary Read Users
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsersApiV1UsersGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.readUsersApiV1UsersGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user.
         * @summary Update User
         * @param {number} userId 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserApiV1UsersUserIdPut(userId: number, userUpdate: UserUpdate, options?: any): AxiosPromise<User> {
            return localVarFp.updateUserApiV1UsersUserIdPut(userId, userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Update own user.
         * @summary Update User Me
         * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options?: any): AxiosPromise<User> {
            return localVarFp.updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Create new user.
     * @summary Create User
     * @param {UserCreate} userCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUserApiV1UsersPost(userCreate: UserCreate, options?: any) {
        return UsersApiFp(this.configuration).createUserApiV1UsersPost(userCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new user without the need to be logged in.
     * @summary Create User Open
     * @param {BodyCreateUserOpenApiV1UsersOpenPost} bodyCreateUserOpenApiV1UsersOpenPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost: BodyCreateUserOpenApiV1UsersOpenPost, options?: any) {
        return UsersApiFp(this.configuration).createUserOpenApiV1UsersOpenPost(bodyCreateUserOpenApiV1UsersOpenPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific user by id.
     * @summary Read User By Id
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUserByIdApiV1UsersUserIdGet(userId: number, options?: any) {
        return UsersApiFp(this.configuration).readUserByIdApiV1UsersUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user.
     * @summary Read User Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUserMeApiV1UsersMeGet(options?: any) {
        return UsersApiFp(this.configuration).readUserMeApiV1UsersMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve users.
     * @summary Read Users
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUsersApiV1UsersGet(skip?: number, limit?: number, options?: any) {
        return UsersApiFp(this.configuration).readUsersApiV1UsersGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user.
     * @summary Update User
     * @param {number} userId 
     * @param {UserUpdate} userUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserApiV1UsersUserIdPut(userId: number, userUpdate: UserUpdate, options?: any) {
        return UsersApiFp(this.configuration).updateUserApiV1UsersUserIdPut(userId, userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update own user.
     * @summary Update User Me
     * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options?: any) {
        return UsersApiFp(this.configuration).updateUserMeApiV1UsersMePut(bodyUpdateUserMeApiV1UsersMePut, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UtilsApi - axios parameter creator
 * @export
 */
export const UtilsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Test Celery worker.
         * @summary Test Celery
         * @param {Msg} msg 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCeleryApiV1UtilsTestCeleryPost: async (msg: Msg, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'msg' is not null or undefined
            assertParamExists('testCeleryApiV1UtilsTestCeleryPost', 'msg', msg)
            const localVarPath = `/api/v1/utils/test-celery/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(msg, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test emails.
         * @summary Test Email
         * @param {string} emailTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testEmailApiV1UtilsTestEmailPost: async (emailTo: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailTo' is not null or undefined
            assertParamExists('testEmailApiV1UtilsTestEmailPost', 'emailTo', emailTo)
            const localVarPath = `/api/v1/utils/test-email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (emailTo !== undefined) {
                localVarQueryParameter['email_to'] = emailTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UtilsApi - functional programming interface
 * @export
 */
export const UtilsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UtilsApiAxiosParamCreator(configuration)
    return {
        /**
         * Test Celery worker.
         * @summary Test Celery
         * @param {Msg} msg 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testCeleryApiV1UtilsTestCeleryPost(msg: Msg, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Msg>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testCeleryApiV1UtilsTestCeleryPost(msg, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test emails.
         * @summary Test Email
         * @param {string} emailTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testEmailApiV1UtilsTestEmailPost(emailTo: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Msg>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testEmailApiV1UtilsTestEmailPost(emailTo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UtilsApi - factory interface
 * @export
 */
export const UtilsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UtilsApiFp(configuration)
    return {
        /**
         * Test Celery worker.
         * @summary Test Celery
         * @param {Msg} msg 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCeleryApiV1UtilsTestCeleryPost(msg: Msg, options?: any): AxiosPromise<Msg> {
            return localVarFp.testCeleryApiV1UtilsTestCeleryPost(msg, options).then((request) => request(axios, basePath));
        },
        /**
         * Test emails.
         * @summary Test Email
         * @param {string} emailTo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testEmailApiV1UtilsTestEmailPost(emailTo: string, options?: any): AxiosPromise<Msg> {
            return localVarFp.testEmailApiV1UtilsTestEmailPost(emailTo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UtilsApi - object-oriented interface
 * @export
 * @class UtilsApi
 * @extends {BaseAPI}
 */
export class UtilsApi extends BaseAPI {
    /**
     * Test Celery worker.
     * @summary Test Celery
     * @param {Msg} msg 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApi
     */
    public testCeleryApiV1UtilsTestCeleryPost(msg: Msg, options?: any) {
        return UtilsApiFp(this.configuration).testCeleryApiV1UtilsTestCeleryPost(msg, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test emails.
     * @summary Test Email
     * @param {string} emailTo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApi
     */
    public testEmailApiV1UtilsTestEmailPost(emailTo: string, options?: any) {
        return UtilsApiFp(this.configuration).testEmailApiV1UtilsTestEmailPost(emailTo, options).then((request) => request(this.axios, this.basePath));
    }
}


